'''
    Code Auto-Generated by chatGPT
'''

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation

# define the objective function
def objective_function(x, y):
    return x**2 - 10*np.cos(2*np.pi*x) + y**2 - 10*np.cos(2*np.pi*y) + 20

# define the PSO function
def PSO(obj_func, num_particles, num_dimensions, num_iterations, w=0.5, c1=1, c2=2):
    # initialize particles
    particles_position = np.random.uniform(low=-5, high=5, size=(num_particles, num_dimensions))
    particles_velocity = np.zeros((num_particles, num_dimensions))
    particles_best_position = particles_position.copy()
    particles_best_value = np.array([np.inf] * num_particles)

    # initialize global best position and value
    global_best_position = np.zeros(num_dimensions)
    global_best_value = np.inf

    # run iterations
    for i in range(num_iterations):
        for j in range(num_particles):
            # evaluate objective function at current particle position
            particle_value = obj_func(particles_position[j][0], particles_position[j][1])

            # update particle best position and value
            if particle_value < particles_best_value[j]:
                particles_best_value[j] = particle_value
                particles_best_position[j] = particles_position[j].copy()

            # update global best position and value
            if particle_value < global_best_value:
                global_best_value = particle_value
                global_best_position = particles_position[j].copy()

            # update particle velocity and position
            particles_velocity[j] = w*particles_velocity[j] + c1*np.random.rand()*(particles_best_position[j] - particles_position[j]) + c2*np.random.rand()*(global_best_position - particles_position[j])
            particles_position[j] = particles_position[j] + particles_velocity[j]

        # plot particles and objective function contour
        plt.clf()
        x = np.linspace(-5, 5, 100)
        y = np.linspace(-5, 5, 100)
        X, Y = np.meshgrid(x, y)
        Z = obj_func(X, Y)
        plt.contour(X, Y, Z, levels=20, alpha=0.5)
        plt.scatter(particles_position[:,0], particles_position[:,1], color='red')
        plt.xlim(-5, 5)
        plt.ylim(-5, 5)
        plt.title(f'Iteration {i+1}')
        plt.pause(0.001)

    return global_best_position, global_best_value

# run PSO algorithm and animate the process
num_particles = 30
num_dimensions = 2
num_iterations = 50
w = 0.5
c1 = 1
c2 = 2
best_position, best_value = PSO(objective_function, num_particles, num_dimensions, num_iterations, w, c1, c2)

# plot final result
x = np.linspace(-5, 5, 100)
y = np.linspace(-5, 5, 100)
X, Y = np.meshgrid(x, y)
Z = objective_function(X, Y)
fig, ax = plt.subplots()
ax.contour(X, Y, Z, levels=20, alpha=0.5)
ax.scatter(best_position[0], best_position[1], marker='*', color='red', s=200)
plt.xlim(-5, 5)
plt.ylim(-5, 5)
plt.title(f'Best Position: {best_position}, Best Value: {best_value}')
plt.show()